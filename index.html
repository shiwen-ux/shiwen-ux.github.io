<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shiwen | Designer</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>·</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      color: #fff;
      font-family: 'JetBrains Mono', monospace;
      overflow-x: hidden;
      min-height: 100vh;
    }

    .ascii-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 75vh;
      z-index: 0;
      overflow: hidden;
    }

    /* Controls Panel */
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #333;
      padding: 20px;
      width: 280px;
      font-size: 11px;
      color: #888;
    }

    .controls.hidden {
      display: none;
    }

    .controls h3 {
      color: #fff;
      font-size: 12px;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
      font-weight: 500;
      letter-spacing: 0.1em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-group label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      color: #888;
    }

    .control-group label span {
      color: #fff;
      font-weight: 500;
    }

    .control-group input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: #333;
      outline: none;
      cursor: pointer;
    }

    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: #fff;
      cursor: pointer;
    }

    .control-group input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #fff;
      cursor: pointer;
      border: none;
    }

    .toggle-controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 101;
      background: #000;
      border: 1px solid #333;
      color: #fff;
      padding: 8px 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      cursor: pointer;
      display: none;
    }

    .controls.hidden + .toggle-controls {
      display: block;
    }

    .btn-toggle {
      background: none;
      border: none;
      color: #888;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      cursor: pointer;
      padding: 0;
    }

    .btn-toggle:hover {
      color: #fff;
    }

    /* Footer */
    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 25vh;
      background: #000;
      padding: 40px;
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: flex-start;
    }

    .footer-main {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .footer p {
      color: #CCC;
      font-size: 24px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      max-width: 800px;
    }

    .footer p .company {
      color: #CCC;
      cursor: pointer;
      transition: color 0.3s ease;
      text-decoration: underline;
    }

    .footer p .company:hover {
      color: #fff;
    }

    .footer-meta {
      display: flex;
      align-items: center;
      gap: 24px;
      color: #888;
      font-size: 16px;
      letter-spacing: 0.05em;
      line-height: 1;
    }

    .footer-meta span {
      cursor: default;
      display: flex;
      align-items: center;
      color: #888;
    }

    .footer-links {
      display: flex;
      align-items: center;
      gap: 24px;
      color: #888;
      font-size: 16px;
      letter-spacing: 0.05em;
    }

    .footer-link {
      color: #888;
      text-decoration: none;
      transition: color 0.3s ease;
    }

    .footer-link:hover {
      color: #fff;
      text-decoration: underline;
    }

    .desktop-break {
      display: block;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .footer {
        height: auto;
        min-height: 20vh;
        padding: 12px 16px;
        gap: 12px;
      }

      .footer p {
        font-size: 20px;
        text-align: left;
        line-height: 1.6;
      }

      .footer-meta {
        flex-wrap: wrap;
        justify-content: flex-start;
        gap: 8px 16px;
        font-size: 12px;
      }

      .desktop-break {
        display: none;
      }

      .controls {
        width: calc(100% - 40px);
        right: 20px;
        left: 20px;
      }

      .toggle-controls {
        font-size: 10px;
        padding: 6px 10px;
      }

      .ascii-background {
        height: 70vh;
      }
    }

    @media (max-width: 480px) {
      .footer p {
        font-size: 18px;
      }

      .footer-meta {
        font-size: 10px;
        gap: 6px 12px;
      }

      .footer {
        padding: 12px;
        min-height: 15vh;
      }

      .ascii-background {
        height: 75vh;
      }
    }
  </style>
</head>
<body>
  <canvas class="ascii-background" id="asciiBackground"></canvas>

  <div class="footer">
    <div class="footer-main">
      <p id="description"><span id="descText">Shiwen is designing AI </span><span id="microsoftBtn" class="company">@Microsoft</span><span id="descText2">, previously </span><span id="mathworksBtn" class="company">@MathWorks</span><span id="descText3">, </span><span id="philipsBtn" class="company">@Philips</span></p>
      <div class="footer-meta">
        <span id="localTime">--:--:-- PST</span>
        <span>Vancouver, BC</span>
      </div>
    </div>
    <div class="footer-links">
      <a href="https://linkedin.com/in/shiwenjiang" target="_blank" class="footer-link">LINKEDIN</a>
      <a href="https://github.com/shiwen-ux" target="_blank" class="footer-link">GITHUB</a>
      <a href="mailto:shiwenjiang331@gmail.com" class="footer-link">EMAIL</a>
    </div>
  </div>

  <div class="controls hidden" id="controls">
    <h3><span>> CONTROLS</span><button class="btn-toggle" id="hideControls">[×]</button></h3>
    <div class="control-group">
      <label>Size <span id="fontSizeVal">12px</span></label>
      <input type="range" id="fontSize" min="12" max="30" value="12">
    </div>
    <div class="control-group">
      <label>Trail Length <span id="trailVal">44</span></label>
      <input type="range" id="trailLength" min="5" max="100" value="44">
    </div>
    <div class="control-group">
      <label>Cursor Size <span id="cursorVal">6</span></label>
      <input type="range" id="cursorSize" min="2" max="15" value="6">
    </div>
  </div>
  
  <button class="toggle-controls" id="showControls">[+] CONTROLS</button>

  <script>
    // DOM Elements
    const canvas = document.getElementById('asciiBackground');
    const ctx = canvas.getContext('2d');
    const controls = document.getElementById('controls');
    
    // Settings
    let settings = { fontSize: 12 };
    let cursorRadius = 6;
    let maxTrailLength = 44;
    
    // Grid state
    let gridData = [];
    let gridWidth = 0;
    let gridHeight = 0;
    let mouseX = -1000;
    let mouseY = -1000;
    let lastMouseX = -1000;
    let lastMouseY = -1000;
    let lastMoveTime = Date.now();
    let trailPoints = [];
    let hasMouseMoved = false;
    let currentRadius = 6; // Dynamic radius that shrinks when idle
    let breatheTime = 0; // For idle breathing animation
    let lastCanvasTouchTime = 0; // Track when cursor last touched canvas
    
    // Logo state
    let activeLogo = null;
    let logoStartTime = 0; // When logo started showing
    let logoEndTime = 0; // When logo stopped showing
    let logoScrambleStart = 0;
    let isScrambling = false;
    let dissolvingLogo = null; // Logo that's dissolving out
    let dissolveStartTime = 0; // When dissolve started
    const dissolveDuration = 500; // 0.5 second dissolve
    const scrambleDuration = 1000;
    const randomChars = 'abcdefghijklmnopqrstuvwxyz0123456789@#$%&*';
    const cursorWord = 'shiwen_';
    
    // Page load scramble effect
    let pageLoadTime = Date.now();
    let isPageLoading = true;
    setTimeout(() => { isPageLoading = false; }, 1000);
    
    const logoWords = {
      microsoft: 'microsoft',
      mathworks: 'mathworks',
      philips: 'philips'
    };
    
    // Logo patterns
    const logoPatterns = {
      microsoft: [
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '                           ',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
      ],
      mathworks: [
        '                             @@@@               ',
        '                            @@@@@@@             ',
        '                          @@@@@@@@@             ',
        '                         @@@@@@@@@@@            ',
        '                        @@ @@@@@@@@@@           ',
        '                     @@@@ @@@@@@@@@@@@          ',
        '                  @@@@@@ @@@@@@@@@@@@@          ',
        '                @@@@@@@ @@@@@@@@@@@@@@@         ',
        '                @@@@@  @@@@@@@@@@@@@@@@         ',
        '          @@@@    @@  @@@@@@@@@@@@@@@@@@        ',
        '     @@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@       ',
        '   @@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@       ',
        '      @@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@      ',
        '         @@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@     ',
        '             @@@@@@@@@@@@@@@@@@@@       @@@@    ',
        '                 @@@@@@@@@@@@@@@          @@    ',
        '                  @@@@@@@@@@@@              @   ',
        '                   @@@@@@@@@                    ',
        '                   @@@@@@@@                     ',
        '                    @@@@@                       ',
      ],
      philips: [
        '###################################',
        '###################################',
        '###....#..#..#..#..##.#-....#...###',
        '###.##.#.....#..#..##.#-.##.#...###',
        '###.####..#..#..#..##.#-.######..##',
        '###################################',
        '###############.....###############',
        '##########...#...........##########',
        '#######..########...........#######',
        '######...##..#...............######',
        '################...............####',
        '###:.....##..........########...###',
        '###......#.......##################',
        '##:..........######.............:##',
        '###############.....###############',
        '##...............#####:.........###',
        '#######....########......#......###',
        ' ##...########*.........##......## ',
        '  ##...............+##########=##  ',
        '   ##...................##....##   ',
        '    ###.............*#...#..###    ',
        '      ###............*....###      ',
        '        ######.......######        ',
        '            ###########            ',
      ]
    };

    // Get cursor character (cycles through "shiwen_")
    function getCursorChar(index) {
      return cursorWord[index % cursorWord.length];
    }
    
    // Eased random value for smooth transitions (0-1)
    function getEasedRandom(x, y, cycleDuration = 400) {
      const time = Date.now();
      const cycleProgress = (time % cycleDuration) / cycleDuration;
      const eased = cycleProgress < 0.5 
        ? 4 * cycleProgress * cycleProgress * cycleProgress 
        : 1 - Math.pow(-2 * cycleProgress + 2, 3) / 2;
      const timeSlot = Math.floor(time / cycleDuration);
      const currentSeed = Math.sin(x * 12.9898 + y * 78.233 + timeSlot) * 43758.5453;
      const nextSeed = Math.sin(x * 12.9898 + y * 78.233 + timeSlot + 1) * 43758.5453;
      const currentRand = currentSeed - Math.floor(currentSeed);
      const nextRand = nextSeed - Math.floor(nextSeed);
      return currentRand + (nextRand - currentRand) * eased;
    }
    
    // Check if character should show based on threshold with randomized edge
    function shouldShowWithEdge(x, y, threshold, coreFactor = 0.6) {
      const random = getEasedRandom(x, y);
      const coreThreshold = threshold * coreFactor;
      if (random < coreThreshold) return true;
      if (random < threshold) {
        // Edge zone: flicker
        const flickerSeed = Math.sin(x * 45.123 + y * 89.456 + Date.now() * 0.008) * 98765.4321;
        return (flickerSeed - Math.floor(flickerSeed)) > 0.5;
      }
      return false;
    }
    
    // Get logo color based on position
    function getLogoColor(logo, patternX, patternY, width, height) {
      const gradient = patternY / height;
      if (logo === 'microsoft') {
        const isTop = patternY < 8;
        const isLeft = patternX < 13;
        if (isTop && isLeft) return '#666';
        if (isTop && !isLeft) return '#888';
        if (!isTop && isLeft) return '#AAA';
        return '#CCC';
      }
      if (logo === 'mathworks') {
        if (gradient < 0.35) return '#CCC';
        if (gradient < 0.55) return '#AAA';
        if (gradient < 0.75) return '#888';
        return '#666';
      }
      // philips
      if (gradient < 0.3) return '#AAA';
      if (gradient < 0.5) return '#999';
      if (gradient < 0.7) return '#888';
      return '#777';
    }
    
    // Check if character should be rendered
    function isLogoChar(logo, char) {
      if (logo === 'microsoft') return char !== ' ';
      if (logo === 'mathworks') return char === '@';
      return char !== ' ' && char !== '.';
    }
    
    // Get logo character with scramble effect
    function getLogoChar(logoWord, index) {
      if (!isScrambling) {
        return logoWord[index % logoWord.length];
      }
      const elapsed = Date.now() - logoScrambleStart;
      const progress = Math.min(elapsed / scrambleDuration, 1);
      const charPosition = index % logoWord.length;
      const revealThreshold = progress * logoWord.length;
      
      if (charPosition < revealThreshold) {
        return logoWord[charPosition];
      }
      return randomChars[Math.floor(Math.random() * randomChars.length)];
    }

    // Generate ASCII background
    function generateASCII() {
      const charWidth = settings.fontSize * 0.6;
      const charHeight = settings.fontSize;
      // Use floor and ensure odd numbers for perfect centering
      gridWidth = Math.floor(canvas.width / charWidth);
      gridHeight = Math.floor(canvas.height / charHeight);
      if (gridWidth % 2 === 0) gridWidth--;
      if (gridHeight % 2 === 0) gridHeight--;
      
      gridData = [];
      let charIndex = 0;
      
      for (let y = 0; y < gridHeight; y++) {
        const row = [];
        for (let x = 0; x < gridWidth; x++) {
          row.push({
            baseChar: '·',
            randomChar: getCursorChar(charIndex++),
            currentChar: null,
            opacity: 0
          });
        }
        gridData.push(row);
      }
    }
    
    // Render grid using Canvas
    function renderGrid() {
      const charWidth = settings.fontSize * 0.6;
      const charHeight = settings.fontSize;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Clip to canvas bounds to prevent overflow
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, canvas.width, canvas.height);
      ctx.clip();
      
      ctx.font = settings.fontSize + 'px "JetBrains Mono", monospace';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Get active logo pattern info
      const pattern = activeLogo ? logoPatterns[activeLogo] : null;
      const patternWidth = pattern ? pattern[0].length : 0;
      const patternHeight = pattern ? pattern.length : 0;
      const startX = pattern ? Math.floor((gridWidth - patternWidth) / 2) : 0;
      const startY = pattern ? Math.floor((gridHeight - patternHeight) / 2) : 0;
      
      let wordIndex = 0;
      
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const cell = gridData[y] && gridData[y][x];
          if (!cell) continue;
          
          const px = x * charWidth + charWidth / 2;
          const py = y * charHeight + charHeight / 2;
          
          // Logo rendering
          if (activeLogo && pattern) {
            const patternY = y - startY;
            const patternX = x - startX;
            
            // Calculate blur effect for nearby dots
            const logoAge = Date.now() - logoStartTime;
            const effectDuration = 1000;
            const linearProgress = Math.min(logoAge / effectDuration, 1);
            const easedProgress = linearProgress < 0.5 
              ? 4 * linearProgress * linearProgress * linearProgress 
              : 1 - Math.pow(-2 * linearProgress + 2, 3) / 2;
            const effectStrength = Math.max(0, 1 - easedProgress);
            
            const blurRadius = 3;
            const isNearLogo = patternY >= -blurRadius && patternY < patternHeight + blurRadius && 
                               patternX >= -blurRadius && patternX < patternWidth + blurRadius;
            
            if (patternY >= 0 && patternY < patternHeight && patternX >= 0 && patternX < patternWidth) {
              const char = pattern[patternY][patternX];
              if (isLogoChar(activeLogo, char)) {
                // Check if edge character and apply randomized edge effect
                if (effectStrength > 0) {
                  let edgeCount = 0;
                  for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                      if (dx === 0 && dy === 0) continue;
                      const ny = patternY + dy, nx = patternX + dx;
                      if (ny < 0 || ny >= patternHeight || nx < 0 || nx >= patternWidth || 
                          !isLogoChar(activeLogo, pattern[ny]?.[nx])) edgeCount++;
                    }
                  }
                  if (edgeCount > 0 && getEasedRandom(x, y) < (edgeCount / 8) * 0.6 * effectStrength) continue;
                }
                
                ctx.fillStyle = getLogoColor(activeLogo, patternX, patternY, patternWidth, patternHeight);
                ctx.fillText(getLogoChar(logoWords[activeLogo], wordIndex++), px, py);
                continue;
              }
            }
            
            // Apply blur to nearby dots
            if (isNearLogo && effectStrength > 0) {
              let minDistToLogo = Infinity;
              for (let dy = -blurRadius; dy <= blurRadius; dy++) {
                for (let dx = -blurRadius; dx <= blurRadius; dx++) {
                  const ny = patternY + dy, nx = patternX + dx;
                  if (ny >= 0 && ny < patternHeight && nx >= 0 && nx < patternWidth && 
                      isLogoChar(activeLogo, pattern[ny][nx])) {
                    minDistToLogo = Math.min(minDistToLogo, Math.sqrt(dx * dx + dy * dy));
                  }
                }
              }
              
              if (minDistToLogo < blurRadius) {
                const blurFactor = 1 - (minDistToLogo / blurRadius);
                if (getEasedRandom(x, y, 200) < blurFactor * 0.7 * effectStrength) {
                  ctx.fillStyle = 'rgba(255,255,255,' + (0.3 + blurFactor * 0.4).toFixed(2) + ')';
                  ctx.fillText(cell.randomChar, px, py);
                  continue;
                }
              }
            }
          }
          
          // Dissolving logo rendering (outro effect)
          if (dissolvingLogo && !activeLogo) {
            const dissolvePattern = logoPatterns[dissolvingLogo];
            const dissolvePatternWidth = dissolvePattern[0].length;
            const dissolvePatternHeight = dissolvePattern.length;
            const dissolveStartX = Math.floor((gridWidth - dissolvePatternWidth) / 2);
            const dissolveStartY = Math.floor((gridHeight - dissolvePatternHeight) / 2);
            const dissolvePatternY = y - dissolveStartY;
            const dissolvePatternX = x - dissolveStartX;
            
            const dissolveAge = Date.now() - dissolveStartTime;
            const dissolveLinear = Math.min(dissolveAge / dissolveDuration, 1);
            const dissolveEased = dissolveLinear < 0.5 
              ? 4 * dissolveLinear * dissolveLinear * dissolveLinear 
              : 1 - Math.pow(-2 * dissolveLinear + 2, 3) / 2;
            const dissolveStrength = 1 - dissolveEased;
            
            if (dissolveAge >= dissolveDuration) {
              dissolvingLogo = null;
            } else if (dissolvePatternY >= 0 && dissolvePatternY < dissolvePatternHeight && 
                       dissolvePatternX >= 0 && dissolvePatternX < dissolvePatternWidth) {
              const dissolveChar = dissolvePattern[dissolvePatternY][dissolvePatternX];
              if (isLogoChar(dissolvingLogo, dissolveChar) && shouldShowWithEdge(x, y, dissolveStrength)) {
                ctx.fillStyle = getLogoColor(dissolvingLogo, dissolvePatternX, dissolvePatternY, dissolvePatternWidth, dissolvePatternHeight);
                ctx.fillText(getLogoChar(logoWords[dissolvingLogo], wordIndex++), px, py);
                continue;
              }
            }
          }
          
          // Trail effect
          if (cell.opacity > 0) {
            ctx.fillStyle = 'rgba(255,255,255,' + cell.opacity.toFixed(2) + ')';
            ctx.fillText(cell.currentChar, px, py);
          } else {
            // Breathing effect when no trail is active
            if (trailPoints.length === 0) {
              // Calculate breathing intensity
              const timeSinceTouch = Date.now() - lastCanvasTouchTime;
              let fadeIn = Math.min(Math.max(timeSinceTouch - 500, 0) / 2000, 1);
              
              // Fade out when logo is showing
              if (activeLogo) {
                const logoFadeOut = Math.min((Date.now() - logoStartTime) / 2000, 1);
                fadeIn = fadeIn * (1 - logoFadeOut);
              } else if (logoEndTime > 0) {
                // Fade back in after logo hides
                const logoFadeIn = Math.min((Date.now() - logoEndTime) / 2000, 1);
                fadeIn = fadeIn * logoFadeIn;
              }
              
              if (fadeIn > 0.01) {
                const wave = Math.sin(breatheTime * 0.001 + x * 0.05 + y * 0.08) * 0.5 + 0.5;
                const baseBrightness = 51; // #333
                const targetBrightness = 20 + wave * 80;
                const brightness = Math.floor(baseBrightness + (targetBrightness - baseBrightness) * fadeIn);
                ctx.fillStyle = 'rgb(' + brightness + ',' + brightness + ',' + brightness + ')';
              } else {
                ctx.fillStyle = '#333';
              }
            } else {
              ctx.fillStyle = '#333';
            }
            ctx.fillText(cell.baseChar, px, py);
          }
        }
      }
      
      ctx.restore();
    }

    // Update cursor trail
    function updateTrail() {
      const charWidth = settings.fontSize * 0.6;
      const charHeight = settings.fontSize;
      const canvasHeight = window.innerHeight * 0.75;
      const gridX = Math.floor(mouseX / charWidth);
      const gridY = Math.floor(mouseY / charHeight);
      
      // Only add new points if cursor is within the canvas area
      const isInCanvas = mouseY < canvasHeight && gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight;
      
      // Check if cursor is moving
      const isMoving = (mouseX !== lastMouseX || mouseY !== lastMouseY);
      if (isMoving) {
        lastMouseX = mouseX;
        lastMouseY = mouseY;
        lastMoveTime = Date.now();
      }
      
      // Fade out if cursor hasn't moved for 500ms
      const idleTime = Date.now() - lastMoveTime;
      const isIdle = idleTime > 500;
      
      if (isInCanvas && !isIdle) {
        trailPoints.unshift({ x: gridX, y: gridY, time: Date.now() });
        lastCanvasTouchTime = Date.now();
        if (trailPoints.length > maxTrailLength) {
          trailPoints.pop();
        }
        // Reset currentRadius to full size when moving
        currentRadius = cursorRadius;
      } else if (trailPoints.length > 0) {
        // When idle, shrink the cursor radius toward center
        currentRadius = Math.max(0, currentRadius - 0.08);
        
        // Remove trail points slowly
        trailPoints.pop();
      }
      
      // Reset all cells
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          gridData[y][x].opacity = 0;
        }
      }
      
      // Apply trail effect with dynamic radius and randomized edges
      const effectRadius = Math.ceil(currentRadius);
      trailPoints.forEach((point, index) => {
        const age = index / maxTrailLength;
        const baseOpacity = (1 - age) * 0.8;
        
        for (let dy = -effectRadius; dy <= effectRadius; dy++) {
          for (let dx = -effectRadius; dx <= effectRadius; dx++) {
            const px = point.x + dx;
            const py = point.y + dy;
            
            if (px >= 0 && px < gridWidth && py >= 0 && py < gridHeight) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= currentRadius) {
                // Randomize the edge: characters near the edge have a chance to not appear
                const edgeThreshold = currentRadius * 0.6;
                let shouldShow = dist <= edgeThreshold || 
                  getEasedRandom(px, py) > (dist - edgeThreshold) / (currentRadius - edgeThreshold) * 0.8;
                
                if (shouldShow && baseOpacity > gridData[py][px].opacity) {
                  gridData[py][px].opacity = baseOpacity;
                  gridData[py][px].currentChar = gridData[py][px].randomChar;
                }
              }
            }
          }
        }
      });
    }

    // Animation loop
    function animate() {
      breatheTime = Date.now();
      updateTrail();
      renderGrid();
      requestAnimationFrame(animate);
    }

    // Update background
    function updateBackground() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight * 0.75;
      generateASCII();
    }

    // Initialize
    updateBackground();
    animate();

    // Throttled mouse move
    let lastMouseUpdate = 0;
    document.addEventListener('mousemove', (e) => {
      const now = Date.now();
      if (now - lastMouseUpdate > 16) { // ~60fps
        mouseX = e.clientX;
        mouseY = e.clientY;
        hasMouseMoved = true;
        lastMouseUpdate = now;
      }
    });

    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
      lastMouseX = mouseX;
      lastMouseY = mouseY;
      lastMoveTime = Date.now();
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const now = Date.now();
      if (now - lastMouseUpdate > 16) {
        const touch = e.touches[0];
        mouseX = touch.clientX;
        mouseY = touch.clientY;
        lastMouseUpdate = now;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      // Trigger idle state after touch ends
      lastMoveTime = Date.now() - 400; // Almost trigger idle fade
    });

    // Debounced resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(updateBackground, 100);
    });

    document.getElementById('fontSize').addEventListener('input', (e) => {
      settings.fontSize = parseInt(e.target.value);
      document.getElementById('fontSizeVal').textContent = settings.fontSize + 'px';
      generateASCII();
    });

    document.getElementById('trailLength').addEventListener('input', (e) => {
      maxTrailLength = parseInt(e.target.value);
      document.getElementById('trailVal').textContent = maxTrailLength;
    });

    document.getElementById('cursorSize').addEventListener('input', (e) => {
      cursorRadius = parseInt(e.target.value);
      document.getElementById('cursorVal').textContent = cursorRadius;
    });

    document.getElementById('hideControls').addEventListener('click', () => {
      controls.classList.add('hidden');
    });

    document.getElementById('showControls').addEventListener('click', () => {
      controls.classList.remove('hidden');
    });

    // Logo hover events
    const microsoftBtn = document.getElementById('microsoftBtn');
    const mathworksBtn = document.getElementById('mathworksBtn');
    const philipsBtn = document.getElementById('philipsBtn');
    
    function startLogoHover(logoName) {
      activeLogo = logoName;
      logoStartTime = Date.now();
      logoScrambleStart = Date.now();
      isScrambling = true;
      setTimeout(() => {
        if (activeLogo === logoName) {
          isScrambling = false;
        }
      }, scrambleDuration);
    }
    
    function endLogoHover() {
      if (activeLogo) {
        dissolvingLogo = activeLogo;
        dissolveStartTime = Date.now();
      }
      activeLogo = null;
      logoEndTime = Date.now();
      isScrambling = false;
    }
    
    microsoftBtn.addEventListener('mouseenter', () => startLogoHover('microsoft'));
    microsoftBtn.addEventListener('mouseleave', endLogoHover);
    mathworksBtn.addEventListener('mouseenter', () => startLogoHover('mathworks'));
    mathworksBtn.addEventListener('mouseleave', endLogoHover);
    philipsBtn.addEventListener('mouseenter', () => startLogoHover('philips'));
    philipsBtn.addEventListener('mouseleave', endLogoHover);

    // Local time (Vancouver, BC)
    function updateTime() {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-US', {
        timeZone: 'America/Vancouver',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      const tzAbbr = now.toLocaleTimeString('en-US', { 
        timeZone: 'America/Vancouver', 
        timeZoneName: 'short' 
      }).split(' ').pop();
      document.getElementById('localTime').textContent = timeStr + ' ' + tzAbbr;
    }
    updateTime();
    setInterval(updateTime, 1000);

    // Weather (Vancouver, BC)
    async function fetchWeather() {
      try {
        const response = await fetch('https://api.open-meteo.com/v1/forecast?latitude=49.2827&longitude=-123.1207&current=temperature_2m,weather_code');
        const data = await response.json();
        const temp = Math.round(data.current.temperature_2m);
        
        document.getElementById('weather').textContent = temp + '°C';
      } catch (e) {
        document.getElementById('weather').textContent = '--°C';
      }
    }
    fetchWeather();
    setInterval(fetchWeather, 600000);

    // Description scramble effect on page load
    const descriptionText = 'SHIWEN IS DESIGNING AI @MICROSOFT, PREVIOUSLY @MATHWORKS, @PHILIPS';
    const descriptionEl = document.getElementById('description');
    const originalHTML = descriptionEl.innerHTML;
    
    function scrambleDescription() {
      const elapsed = Date.now() - pageLoadTime;
      const progress = Math.min(elapsed / 1000, 1);
      const revealCount = Math.floor(progress * descriptionText.length);
      
      let scrambledText = '';
      for (let i = 0; i < descriptionText.length; i++) {
        if (descriptionText[i] === ' ') {
          scrambledText += ' ';
        } else if (i < revealCount) {
          scrambledText += descriptionText[i];
        } else {
          scrambledText += randomChars[Math.floor(Math.random() * randomChars.length)].toUpperCase();
        }
      }
      
      descriptionEl.textContent = scrambledText;
      
      if (progress < 1) {
        requestAnimationFrame(scrambleDescription);
      } else {
        // Restore original HTML with interactive spans
        descriptionEl.innerHTML = originalHTML;
        // Re-attach event listeners
        document.getElementById('microsoftBtn').addEventListener('mouseenter', () => startLogoHover('microsoft'));
        document.getElementById('microsoftBtn').addEventListener('mouseleave', endLogoHover);
        document.getElementById('mathworksBtn').addEventListener('mouseenter', () => startLogoHover('mathworks'));
        document.getElementById('mathworksBtn').addEventListener('mouseleave', endLogoHover);
        document.getElementById('philipsBtn').addEventListener('mouseenter', () => startLogoHover('philips'));
        document.getElementById('philipsBtn').addEventListener('mouseleave', endLogoHover);
      }
    }
    scrambleDescription();
  </script>
</body>
</html>

