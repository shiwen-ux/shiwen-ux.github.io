<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shiwen | Designer</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='50' fill='white'>>_</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://cdn.jsdelivr.net/npm/@fontsource/monaspace-neon@5.0.1/index.css" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    ::selection {
      background: #fff;
      color: #000;
    }

    ::-moz-selection {
      background: #fff;
      color: #000;
    }

    body {
      background: #000;
      color: #fff;
      font-family: 'Monaspace Neon', monospace;
      overflow-x: hidden;
      min-height: 100vh;
    }

    .ascii-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 75vh;
      z-index: 0;
      overflow: hidden;
    }

    /* Controls Panel */
    .controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid #333;
      padding: 20px;
      width: 280px;
      font-size: 11px;
      color: #888;
    }

    .controls.hidden {
      display: none;
    }

    .controls h3 {
      color: #fff;
      font-size: 12px;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 1px solid #333;
      font-weight: 500;
      letter-spacing: 0.1em;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .control-group {
      margin-bottom: 16px;
    }

    .control-group label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
      color: #888;
    }

    .control-group label span {
      color: #fff;
      font-weight: 500;
    }

    .control-group input[type="range"] {
      width: 100%;
      height: 4px;
      -webkit-appearance: none;
      appearance: none;
      background: #333;
      outline: none;
      cursor: pointer;
    }

    .control-group input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      background: #fff;
      cursor: pointer;
    }

    .control-group input[type="range"]::-moz-range-thumb {
      width: 12px;
      height: 12px;
      background: #fff;
      cursor: pointer;
      border: none;
    }

    .toggle-controls {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 101;
      background: #000;
      border: 1px solid #333;
      color: #fff;
      padding: 8px 12px;
      font-family: 'JetBrains Mono', monospace;
      font-size: 11px;
      cursor: pointer;
      display: none;
    }

    .controls.hidden + .toggle-controls {
      display: block;
    }

    .btn-toggle {
      background: none;
      border: none;
      color: #888;
      font-family: 'JetBrains Mono', monospace;
      font-size: 14px;
      cursor: pointer;
      padding: 0;
    }

    .btn-toggle:hover {
      color: #fff;
    }

    /* Footer */
    .footer {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 25vh;
      background: #000;
      padding: clamp(12px, 2vh, 24px) clamp(16px, 4vw, 40px);
      z-index: 10;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
    }

    .footer-main {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .footer-description {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .footer p {
      color: #fff;
      font-size: 24px;
      letter-spacing: 0.05em;
      text-transform: uppercase;
      max-width: 800px;
    }

    .footer p.previously {
      color: #888;
    }

    .footer p .company {
      color: #888;
      cursor: pointer;
      transition: color 0.3s ease;
      text-decoration: underline;
    }

    .footer p .company.primary {
      color: #fff;
    }

    .footer p .company:hover {
      color: #fff;
    }

    .footer-meta {
      display: flex;
      align-items: center;
      gap: 24px;
      color: #888;
      font-size: 16px;
      letter-spacing: 0.05em;
      line-height: 1;
    }

    .footer-meta span {
      cursor: default;
      display: flex;
      align-items: center;
      color: #888;
    }

    .footer-links {
      display: flex;
      align-items: center;
      gap: 24px;
      font-size: 12px;
      letter-spacing: 0.05em;
    }

    .footer-link {
      color: #888;
      text-decoration: none;
      transition: color 0.3s ease;
      padding: 8px 0;
      min-height: 44px;
      display: inline-flex;
      align-items: center;
    }

    .footer-link:hover {
      color: #ccc;
      text-decoration: underline;
    }

    .footer-link:focus {
      color: #ccc;
      text-decoration: underline;
      outline: 1px solid #888;
      outline-offset: 4px;
    }

    .footer p .company:focus {
      color: #fff;
      outline: 1px solid #888;
      outline-offset: 4px;
    }

    .desktop-break {
      display: block;
    }

    /* Mobile Responsive */
    @media (max-width: 768px) {
      .footer {
        height: auto;
        min-height: 20vh;
        gap: 12px;
      }

      .footer p {
        font-size: 20px;
        text-align: left;
        line-height: 1.6;
      }

      .footer-meta {
        flex-wrap: wrap;
        justify-content: flex-start;
        gap: 8px 16px;
        font-size: 12px;
      }

      .footer-links {
        font-size: 12px;
      }

      .desktop-break {
        display: none;
      }

      .controls {
        width: calc(100% - 40px);
        right: 20px;
        left: 20px;
      }

      .toggle-controls {
        font-size: 10px;
        padding: 6px 10px;
      }

      .ascii-background {
        height: 70vh;
      }
    }

    @media (max-width: 480px) {
      .footer p {
        font-size: 18px;
      }

      .footer-meta {
        font-size: 12px;
        gap: 6px 12px;
      }

      .footer-links {
        font-size: 12px;
      }

      .footer {
        padding: 12px;
        min-height: 15vh;
      }

      .ascii-background {
        height: 75vh;
      }
    }
  </style>
</head>
<body>
  <canvas class="ascii-background" id="asciiBackground"></canvas>

  <div class="footer">
    <div class="footer-main">
      <div class="footer-description">
        <p id="description1"><span id="descText">Shiwen is designing AI for Devs </span><span id="microsoftBtn" class="company primary">@Microsoft</span></p>
        <p id="description2" class="previously"><span id="descText2">previously </span><span id="mathworksBtn" class="company">@MathWorks</span><span id="descText3">, </span><span id="philipsBtn" class="company">@Philips</span></p>
      </div>
      <div class="footer-meta">
        <span id="localTime">--:--:-- PST</span>
        <span>Vancouver, BC</span>
      </div>
    </div>
    <div class="footer-links">
      <a href="https://linkedin.com/in/shiwenjiang" target="_blank" rel="noopener" class="footer-link">LINKEDIN</a>
      <a href="https://github.com/shiwen-ux" target="_blank" rel="noopener" class="footer-link">GITHUB</a>
      <a href="mailto:shiwenjiang331@gmail.com" class="footer-link">EMAIL</a>
    </div>
  </div>

  <div class="controls hidden" id="controls">
    <h3><span>> CONTROLS</span><button class="btn-toggle" id="hideControls">[×]</button></h3>
    <div class="control-group">
      <label>Size <span id="fontSizeVal">12px</span></label>
      <input type="range" id="fontSize" min="12" max="30" value="12">
    </div>
    <div class="control-group">
      <label>Trail Length <span id="trailVal">44</span></label>
      <input type="range" id="trailLength" min="5" max="100" value="44">
    </div>
    <div class="control-group">
      <label>Cursor Size <span id="cursorVal">6</span></label>
      <input type="range" id="cursorSize" min="2" max="15" value="6">
    </div>
  </div>
  
  <button class="toggle-controls" id="showControls">[+] CONTROLS</button>

  <script>
    // DOM Elements
    const canvas = document.getElementById('asciiBackground');
    const ctx = canvas.getContext('2d');
    const controls = document.getElementById('controls');
    
    // Offscreen canvas for static background (performance optimization)
    const staticCanvas = document.createElement('canvas');
    const staticCtx = staticCanvas.getContext('2d');
    let staticBackgroundDirty = true; // Flag to know when to redraw static background
    
    // Accessibility: Check for reduced motion preference
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    
    // Performance: Detect Safari and throttle frame rate
    const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    let lastFrameTime = 0;
    const targetFPS = isSafari ? 30 : 60; // Throttle Safari to 30fps
    const frameInterval = 1000 / targetFPS;
    
    // Settings
    let settings = { fontSize: 12 };
    let cursorRadius = 6;
    let maxTrailLength = 44;
    
    // Grid state
    let gridData = [];
    let gridWidth = 0;
    let gridHeight = 0;
    let mouseX = -1000;
    let mouseY = -1000;
    let lastMouseX = -1000;
    let lastMouseY = -1000;
    let lastMoveTime = Date.now();
    let trailPoints = [];
    let hasMouseMoved = false;
    let currentRadius = 6; // Dynamic radius that shrinks when idle
    let breatheTime = 0; // For idle breathing animation
    let lastCanvasTouchTime = 0; // Track when cursor last touched canvas
    
    // Disable trail if reduced motion is preferred
    if (prefersReducedMotion) {
      maxTrailLength = 0;
    }
    
    // Logo state
    let activeLogo = null;
    let logoStartTime = 0; // When logo started showing
    let logoEndTime = 0; // When logo stopped showing
    let logoScrambleStart = 0;
    let isScrambling = false;
    let dissolvingLogo = null; // Logo that's dissolving out
    let dissolveStartTime = 0; // When dissolve started
    const dissolveDuration = 500; // 0.5 second dissolve
    const scrambleDuration = 1000;
    const randomChars = 'abcdefghijklmnopqrstuvwxyz0123456789@#$%&*';
    const cursorWord = 'shiwen_';
    
    // Page load scramble effect
    let pageLoadTime = Date.now();
    let isPageLoading = prefersReducedMotion ? false : true;
    if (!prefersReducedMotion) {
      setTimeout(() => { isPageLoading = false; }, 1000);
    }
    
    const logoWords = {
      microsoft: 'microsoft',
      mathworks: 'mathworks',
      philips: 'philips'
    };
    
    // Logo patterns
    const logoPatterns = {
      microsoft: [
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '                           ',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
        '############# #############',
      ],
      mathworks: [
        '                             @@@@               ',
        '                            @@@@@@@             ',
        '                          @@@@@@@@@             ',
        '                         @@@@@@@@@@@            ',
        '                        @@ @@@@@@@@@@           ',
        '                     @@@@ @@@@@@@@@@@@          ',
        '                  @@@@@@ @@@@@@@@@@@@@          ',
        '                @@@@@@@ @@@@@@@@@@@@@@@         ',
        '                @@@@@  @@@@@@@@@@@@@@@@         ',
        '          @@@@    @@  @@@@@@@@@@@@@@@@@@        ',
        '     @@@@@@@@@@@@    @@@@@@@@@@@@@@@@@@@@       ',
        '   @@@@@@@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@       ',
        '      @@@@@@@@   @@@@@@@@@@@@@@@@@@@@@@@@@      ',
        '         @@@   @@@@@@@@@@@@@@@@@@@@@@@@@@@@     ',
        '             @@@@@@@@@@@@@@@@@@@@       @@@@    ',
        '                 @@@@@@@@@@@@@@@          @@    ',
        '                  @@@@@@@@@@@@              @   ',
        '                   @@@@@@@@@                    ',
        '                   @@@@@@@@                     ',
        '                    @@@@@                       ',
      ],
      philips: [
        '###################################',
        '###################################',
        '###....#..#..#..#..##.#-....#...###',
        '###.##.#.....#..#..##.#-.##.#...###',
        '###.####..#..#..#..##.#-.######..##',
        '###################################',
        '###############.....###############',
        '##########...#...........##########',
        '#######..########...........#######',
        '######...##..#...............######',
        '################...............####',
        '###:.....##..........########...###',
        '###......#.......##################',
        '##:..........######.............:##',
        '###############.....###############',
        '##...............#####:.........###',
        '#######....########......#......###',
        ' ##...########*.........##......## ',
        '  ##...............+##########=##  ',
        '   ##...................##....##   ',
        '    ###.............*#...#..###    ',
        '      ###............*....###      ',
        '        ######.......######        ',
        '            ###########            ',
      ]
    };

    // Get cursor character (cycles through "shiwen_")
    function getCursorChar(index) {
      return cursorWord[index % cursorWord.length];
    }
    
    // Eased random value for smooth transitions (0-1)
    function getEasedRandom(x, y, cycleDuration = 400) {
      const time = Date.now();
      const cycleProgress = (time % cycleDuration) / cycleDuration;
      const eased = cycleProgress < 0.5 
        ? 4 * cycleProgress * cycleProgress * cycleProgress 
        : 1 - Math.pow(-2 * cycleProgress + 2, 3) / 2;
      const timeSlot = Math.floor(time / cycleDuration);
      const currentSeed = Math.sin(x * 12.9898 + y * 78.233 + timeSlot) * 43758.5453;
      const nextSeed = Math.sin(x * 12.9898 + y * 78.233 + timeSlot + 1) * 43758.5453;
      const currentRand = currentSeed - Math.floor(currentSeed);
      const nextRand = nextSeed - Math.floor(nextSeed);
      return currentRand + (nextRand - currentRand) * eased;
    }
    
    // Check if character should show based on threshold with randomized edge
    function shouldShowWithEdge(x, y, threshold, coreFactor = 0.6) {
      const random = getEasedRandom(x, y);
      const coreThreshold = threshold * coreFactor;
      if (random < coreThreshold) return true;
      if (random < threshold) {
        // Edge zone: flicker
        const flickerSeed = Math.sin(x * 45.123 + y * 89.456 + Date.now() * 0.008) * 98765.4321;
        return (flickerSeed - Math.floor(flickerSeed)) > 0.5;
      }
      return false;
    }
    
    // Get logo color based on position (using consistent grayscale: #fff, #ccc, #888)
    function getLogoColor(logo, patternX, patternY, width, height) {
      const gradient = patternY / height;
      if (logo === 'microsoft') {
        const isTop = patternY < 8;
        const isLeft = patternX < 13;
        if (isTop && isLeft) return '#888';
        if (isTop && !isLeft) return '#ccc';
        if (!isTop && isLeft) return '#ccc';
        return '#fff';
      }
      if (logo === 'mathworks') {
        if (gradient < 0.35) return '#fff';
        if (gradient < 0.6) return '#ccc';
        return '#888';
      }
      // philips
      if (gradient < 0.35) return '#fff';
      if (gradient < 0.6) return '#ccc';
      return '#888';
    }
    
    // Check if character should be rendered
    function isLogoChar(logo, char) {
      if (logo === 'microsoft') return char !== ' ';
      if (logo === 'mathworks') return char === '@';
      return char !== ' ' && char !== '.';
    }
    
    // Get logo character with scramble effect
    function getLogoChar(logoWord, index) {
      if (!isScrambling) {
        return logoWord[index % logoWord.length];
      }
      const elapsed = Date.now() - logoScrambleStart;
      const progress = Math.min(elapsed / scrambleDuration, 1);
      const charPosition = index % logoWord.length;
      const revealThreshold = progress * logoWord.length;
      
      if (charPosition < revealThreshold) {
        return logoWord[charPosition];
      }
      return randomChars[Math.floor(Math.random() * randomChars.length)];
    }

    // Generate ASCII background
    function generateASCII() {
      const charWidth = settings.fontSize * 0.6;
      const charHeight = settings.fontSize;
      // Use floor and ensure odd numbers for perfect centering
      gridWidth = Math.floor(canvas.width / charWidth);
      gridHeight = Math.floor(canvas.height / charHeight);
      if (gridWidth % 2 === 0) gridWidth--;
      if (gridHeight % 2 === 0) gridHeight--;
      
      // Mark static background for redraw
      staticBackgroundDirty = true;
      
      gridData = [];
      let charIndex = 0;
      
      for (let y = 0; y < gridHeight; y++) {
        const row = [];
        for (let x = 0; x < gridWidth; x++) {
          row.push({
            baseChar: '·',
            randomChar: getCursorChar(charIndex++),
            currentChar: null,
            opacity: 0
          });
        }
        gridData.push(row);
      }
    }
    
    // Cache computed values
    let cachedCharWidth = settings.fontSize * 0.6;
    let cachedCharHeight = settings.fontSize;
    let cachedFont = settings.fontSize + 'px "JetBrains Mono", monospace';
    
    function updateCachedValues() {
      cachedCharWidth = settings.fontSize * 0.6;
      cachedCharHeight = settings.fontSize;
      cachedFont = settings.fontSize + 'px "JetBrains Mono", monospace';
    }
    
    // Render static background (dots only) to offscreen canvas
    function renderStaticBackground() {
      staticCanvas.width = canvas.width;
      staticCanvas.height = canvas.height;
      staticCtx.clearRect(0, 0, staticCanvas.width, staticCanvas.height);
      staticCtx.font = cachedFont;
      staticCtx.textAlign = 'center';
      staticCtx.textBaseline = 'middle';
      staticCtx.fillStyle = '#333';
      
      const charWidth = cachedCharWidth;
      const charHeight = cachedCharHeight;
      
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const px = x * charWidth + charWidth / 2;
          const py = y * charHeight + charHeight / 2;
          staticCtx.fillText('·', px, py);
        }
      }
      staticBackgroundDirty = false;
    }
    
    // Render grid using Canvas
    function renderGrid() {
      // Redraw static background if needed
      if (staticBackgroundDirty) {
        renderStaticBackground();
      }
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      ctx.font = cachedFont;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const charWidth = cachedCharWidth;
      const charHeight = cachedCharHeight;
      
      // Get active logo pattern info
      const pattern = activeLogo ? logoPatterns[activeLogo] : null;
      const patternWidth = pattern ? pattern[0].length : 0;
      const patternHeight = pattern ? pattern.length : 0;
      const startX = pattern ? Math.floor((gridWidth - patternWidth) / 2) : 0;
      const startY = pattern ? Math.floor((gridHeight - patternHeight) / 2) : 0;
      
      // Check if we have any dynamic content to render
      const hasTrail = trailPoints.length > 0;
      const hasLogo = activeLogo || dissolvingLogo;
      const hasBreathing = !hasTrail && !prefersReducedMotion;
      
      // Calculate breathing fade values once (outside the loop)
      let breathingFadeIn = 0;
      if (hasBreathing) {
        const timeSinceTouch = Date.now() - lastCanvasTouchTime;
        breathingFadeIn = Math.min(Math.max(timeSinceTouch - 500, 0) / 2000, 1);
        
        if (activeLogo) {
          const logoFadeOut = Math.min((Date.now() - logoStartTime) / 2000, 1);
          breathingFadeIn = breathingFadeIn * (1 - logoFadeOut);
        } else if (logoEndTime > 0) {
          const logoFadeIn = Math.min((Date.now() - logoEndTime) / 2000, 1);
          breathingFadeIn = breathingFadeIn * logoFadeIn;
        }
      }
      
      // Use static background only when there's no breathing effect active
      const useStaticBg = !hasBreathing || breathingFadeIn < 0.01;
      if (useStaticBg) {
        ctx.drawImage(staticCanvas, 0, 0);
      }
      
      // If no dynamic content and using static bg, we're done
      if (!hasTrail && !hasLogo && useStaticBg) return;
      
      let wordIndex = 0;
      
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          const cell = gridData[y] && gridData[y][x];
          if (!cell) continue;
          
          const px = x * charWidth + charWidth / 2;
          const py = y * charHeight + charHeight / 2;
          
          // Logo rendering
          if (activeLogo && pattern) {
            const patternY = y - startY;
            const patternX = x - startX;
            
            // Calculate blur effect for nearby dots
            const logoAge = Date.now() - logoStartTime;
            const effectDuration = 1000;
            const linearProgress = Math.min(logoAge / effectDuration, 1);
            const easedProgress = linearProgress < 0.5 
              ? 4 * linearProgress * linearProgress * linearProgress 
              : 1 - Math.pow(-2 * linearProgress + 2, 3) / 2;
            const effectStrength = Math.max(0, 1 - easedProgress);
            
            const blurRadius = 3;
            const isNearLogo = patternY >= -blurRadius && patternY < patternHeight + blurRadius && 
                               patternX >= -blurRadius && patternX < patternWidth + blurRadius;
            
            if (patternY >= 0 && patternY < patternHeight && patternX >= 0 && patternX < patternWidth) {
              const char = pattern[patternY][patternX];
              if (isLogoChar(activeLogo, char)) {
                // Check if edge character and apply randomized edge effect
                if (effectStrength > 0) {
                  let edgeCount = 0;
                  for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                      if (dx === 0 && dy === 0) continue;
                      const ny = patternY + dy, nx = patternX + dx;
                      if (ny < 0 || ny >= patternHeight || nx < 0 || nx >= patternWidth || 
                          !isLogoChar(activeLogo, pattern[ny]?.[nx])) edgeCount++;
                    }
                  }
                  if (edgeCount > 0 && getEasedRandom(x, y) < (edgeCount / 8) * 0.6 * effectStrength) continue;
                }
                
                ctx.fillStyle = getLogoColor(activeLogo, patternX, patternY, patternWidth, patternHeight);
                ctx.fillText(getLogoChar(logoWords[activeLogo], wordIndex++), px, py);
                continue;
              }
            }
            
            // Apply blur to nearby dots
            if (isNearLogo && effectStrength > 0) {
              let minDistToLogo = Infinity;
              for (let dy = -blurRadius; dy <= blurRadius; dy++) {
                for (let dx = -blurRadius; dx <= blurRadius; dx++) {
                  const ny = patternY + dy, nx = patternX + dx;
                  if (ny >= 0 && ny < patternHeight && nx >= 0 && nx < patternWidth && 
                      isLogoChar(activeLogo, pattern[ny][nx])) {
                    minDistToLogo = Math.min(minDistToLogo, Math.sqrt(dx * dx + dy * dy));
                  }
                }
              }
              
              if (minDistToLogo < blurRadius) {
                const blurFactor = 1 - (minDistToLogo / blurRadius);
                if (getEasedRandom(x, y, 200) < blurFactor * 0.7 * effectStrength) {
                  ctx.fillStyle = 'rgba(255,255,255,' + (0.3 + blurFactor * 0.4).toFixed(2) + ')';
                  ctx.fillText(cell.randomChar, px, py);
                  continue;
                }
              }
            }
          }
          
          // Dissolving logo rendering (outro effect)
          if (dissolvingLogo && !activeLogo) {
            const dissolvePattern = logoPatterns[dissolvingLogo];
            const dissolvePatternWidth = dissolvePattern[0].length;
            const dissolvePatternHeight = dissolvePattern.length;
            const dissolveStartX = Math.floor((gridWidth - dissolvePatternWidth) / 2);
            const dissolveStartY = Math.floor((gridHeight - dissolvePatternHeight) / 2);
            const dissolvePatternY = y - dissolveStartY;
            const dissolvePatternX = x - dissolveStartX;
            
            const dissolveAge = Date.now() - dissolveStartTime;
            const dissolveLinear = Math.min(dissolveAge / dissolveDuration, 1);
            const dissolveEased = dissolveLinear < 0.5 
              ? 4 * dissolveLinear * dissolveLinear * dissolveLinear 
              : 1 - Math.pow(-2 * dissolveLinear + 2, 3) / 2;
            const dissolveStrength = 1 - dissolveEased;
            
            if (dissolveAge >= dissolveDuration) {
              dissolvingLogo = null;
            } else if (dissolvePatternY >= 0 && dissolvePatternY < dissolvePatternHeight && 
                       dissolvePatternX >= 0 && dissolvePatternX < dissolvePatternWidth) {
              const dissolveChar = dissolvePattern[dissolvePatternY][dissolvePatternX];
              if (isLogoChar(dissolvingLogo, dissolveChar) && shouldShowWithEdge(x, y, dissolveStrength)) {
                ctx.fillStyle = getLogoColor(dissolvingLogo, dissolvePatternX, dissolvePatternY, dissolvePatternWidth, dissolvePatternHeight);
                ctx.fillText(getLogoChar(logoWords[dissolvingLogo], wordIndex++), px, py);
                continue;
              }
            }
          }
          
          // Trail effect - draw over static background
          if (cell.opacity > 0) {
            ctx.fillStyle = 'rgba(255,255,255,' + cell.opacity.toFixed(2) + ')';
            ctx.fillText(cell.currentChar, px, py);
          } else if (hasBreathing && breathingFadeIn > 0.01) {
            // Breathing effect - draw all dots with wave brightness
            const wave = Math.sin(breatheTime * 0.001 + x * 0.05 + y * 0.08);
            const baseBrightness = 51; // #333
            // Oscillate symmetrically around #333 (range: 21-81)
            const brightness = Math.floor(baseBrightness + wave * 30 * breathingFadeIn);
            ctx.fillStyle = 'rgb(' + brightness + ',' + brightness + ',' + brightness + ')';
            ctx.fillText(cell.baseChar, px, py);
          }
          // else: static background already has the dot (or was drawn above)
        }
      }
      
    }

    // Update cursor trail
    function updateTrail() {
      const charWidth = cachedCharWidth;
      const charHeight = cachedCharHeight;
      const canvasHeight = window.innerHeight * 0.75;
      const gridX = Math.floor(mouseX / charWidth);
      const gridY = Math.floor(mouseY / charHeight);
      
      // Only add new points if cursor is within the canvas area
      const isInCanvas = mouseY < canvasHeight && gridX >= 0 && gridX < gridWidth && gridY >= 0 && gridY < gridHeight;
      
      // Check if cursor is moving
      const isMoving = (mouseX !== lastMouseX || mouseY !== lastMouseY);
      if (isMoving) {
        lastMouseX = mouseX;
        lastMouseY = mouseY;
        lastMoveTime = Date.now();
      }
      
      // Fade out if cursor hasn't moved for 500ms
      const idleTime = Date.now() - lastMoveTime;
      const isIdle = idleTime > 500;
      
      if (isInCanvas && !isIdle) {
        trailPoints.unshift({ x: gridX, y: gridY, time: Date.now() });
        lastCanvasTouchTime = Date.now();
        if (trailPoints.length > maxTrailLength) {
          trailPoints.pop();
        }
        // Reset currentRadius to full size when moving
        currentRadius = cursorRadius;
      } else if (trailPoints.length > 0) {
        // When idle, shrink the cursor radius toward center
        currentRadius = Math.max(0, currentRadius - 0.08);
        
        // Remove trail points slowly
        trailPoints.pop();
      }
      
      // Reset all cells
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          gridData[y][x].opacity = 0;
        }
      }
      
      // Apply trail effect with dynamic radius and randomized edges
      const effectRadius = Math.ceil(currentRadius);
      trailPoints.forEach((point, index) => {
        const age = index / maxTrailLength;
        const baseOpacity = (1 - age) * 0.8;
        
        for (let dy = -effectRadius; dy <= effectRadius; dy++) {
          for (let dx = -effectRadius; dx <= effectRadius; dx++) {
            const px = point.x + dx;
            const py = point.y + dy;
            
            if (px >= 0 && px < gridWidth && py >= 0 && py < gridHeight) {
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist <= currentRadius) {
                // Randomize the edge: characters near the edge have a chance to not appear
                const edgeThreshold = currentRadius * 0.6;
                let shouldShow = dist <= edgeThreshold || 
                  getEasedRandom(px, py) > (dist - edgeThreshold) / (currentRadius - edgeThreshold) * 0.8;
                
                if (shouldShow && baseOpacity > gridData[py][px].opacity) {
                  gridData[py][px].opacity = baseOpacity;
                  gridData[py][px].currentChar = gridData[py][px].randomChar;
                }
              }
            }
          }
        }
      });
    }

    // Animation loop with frame throttling for Safari
    function animate(currentTime) {
      requestAnimationFrame(animate);
      
      // Throttle frame rate
      if (currentTime - lastFrameTime < frameInterval) return;
      lastFrameTime = currentTime;
      
      breatheTime = Date.now();
      updateTrail();
      renderGrid();
    }

    // Update background
    function updateBackground() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight * 0.75;
      updateCachedValues();
      generateASCII();
    }

    // Initialize
    updateBackground();
    animate();

    // Throttled mouse move
    let lastMouseUpdate = 0;
    document.addEventListener('mousemove', (e) => {
      const now = Date.now();
      if (now - lastMouseUpdate > 16) { // ~60fps
        mouseX = e.clientX;
        mouseY = e.clientY;
        hasMouseMoved = true;
        lastMouseUpdate = now;
      }
    });

    // Touch support for mobile
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      mouseX = touch.clientX;
      mouseY = touch.clientY;
      lastMouseX = mouseX;
      lastMouseY = mouseY;
      lastMoveTime = Date.now();
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const now = Date.now();
      if (now - lastMouseUpdate > 16) {
        const touch = e.touches[0];
        mouseX = touch.clientX;
        mouseY = touch.clientY;
        lastMouseUpdate = now;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      // Trigger idle state after touch ends
      lastMoveTime = Date.now() - 400; // Almost trigger idle fade
    });

    // Debounced resize
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(updateBackground, 100);
    });

    document.getElementById('fontSize').addEventListener('input', (e) => {
      settings.fontSize = parseInt(e.target.value);
      document.getElementById('fontSizeVal').textContent = settings.fontSize + 'px';
      updateCachedValues();
      generateASCII();
    });

    document.getElementById('trailLength').addEventListener('input', (e) => {
      maxTrailLength = parseInt(e.target.value);
      document.getElementById('trailVal').textContent = maxTrailLength;
    });

    document.getElementById('cursorSize').addEventListener('input', (e) => {
      cursorRadius = parseInt(e.target.value);
      document.getElementById('cursorVal').textContent = cursorRadius;
    });

    document.getElementById('hideControls').addEventListener('click', () => {
      controls.classList.add('hidden');
    });

    document.getElementById('showControls').addEventListener('click', () => {
      controls.classList.remove('hidden');
    });

    // Logo hover events
    const microsoftBtn = document.getElementById('microsoftBtn');
    const mathworksBtn = document.getElementById('mathworksBtn');
    const philipsBtn = document.getElementById('philipsBtn');
    
    function startLogoHover(logoName) {
      activeLogo = logoName;
      logoStartTime = Date.now();
      if (!prefersReducedMotion) {
        logoScrambleStart = Date.now();
        isScrambling = true;
        setTimeout(() => {
          if (activeLogo === logoName) {
            isScrambling = false;
          }
        }, scrambleDuration);
      }
    }
    
    function endLogoHover() {
      if (activeLogo && !prefersReducedMotion) {
        dissolvingLogo = activeLogo;
        dissolveStartTime = Date.now();
      }
      activeLogo = null;
      logoEndTime = Date.now();
      isScrambling = false;
    }
    
    microsoftBtn.addEventListener('mouseenter', () => startLogoHover('microsoft'));
    microsoftBtn.addEventListener('mouseleave', endLogoHover);
    mathworksBtn.addEventListener('mouseenter', () => startLogoHover('mathworks'));
    mathworksBtn.addEventListener('mouseleave', endLogoHover);
    philipsBtn.addEventListener('mouseenter', () => startLogoHover('philips'));
    philipsBtn.addEventListener('mouseleave', endLogoHover);

    // Local time (Vancouver, BC)
    function updateTime() {
      const now = new Date();
      const timeStr = now.toLocaleTimeString('en-US', {
        timeZone: 'America/Vancouver',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
      });
      const tzAbbr = now.toLocaleTimeString('en-US', { 
        timeZone: 'America/Vancouver', 
        timeZoneName: 'short' 
      }).split(' ').pop();
      document.getElementById('localTime').textContent = timeStr + ' ' + tzAbbr;
    }
    updateTime();
    setInterval(updateTime, 1000);

    // Description scramble effect on page load - two separate lines
    const line1Text = 'SHIWEN IS DESIGNING AI FOR DEVS @MICROSOFT';
    const line2Text = 'PREVIOUSLY @MATHWORKS, @PHILIPS';
    const line1El = document.getElementById('description1');
    const line2El = document.getElementById('description2');
    const line1OriginalHTML = line1El.innerHTML;
    const line2OriginalHTML = line2El.innerHTML;
    const line1Duration = 800;
    const line2Delay = 0;
    const line2Duration = 800;
    
    function scrambleLine(text, el, startTime, duration) {
      const elapsed = Date.now() - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const revealCount = Math.floor(progress * text.length);
      
      let scrambledText = '';
      for (let i = 0; i < text.length; i++) {
        if (text[i] === ' ') {
          scrambledText += ' ';
        } else if (i < revealCount) {
          scrambledText += text[i];
        } else {
          scrambledText += randomChars[Math.floor(Math.random() * randomChars.length)].toUpperCase();
        }
      }
      return { scrambledText, progress };
    }
    
    function scrambleDescription() {
      const elapsed = Date.now() - pageLoadTime;
      
      // Line 1 animation
      const line1Result = scrambleLine(line1Text, line1El, pageLoadTime, line1Duration);
      line1El.textContent = line1Result.scrambledText;
      
      // Line 2 animation (delayed start)
      if (elapsed >= line2Delay) {
        const line2Result = scrambleLine(line2Text, line2El, pageLoadTime + line2Delay, line2Duration);
        line2El.textContent = line2Result.scrambledText;
        
        if (line1Result.progress >= 1 && line2Result.progress >= 1) {
          // Restore original HTML with interactive spans
          line1El.innerHTML = line1OriginalHTML;
          line2El.innerHTML = line2OriginalHTML;
          // Re-attach event listeners
          document.getElementById('microsoftBtn').addEventListener('mouseenter', () => startLogoHover('microsoft'));
          document.getElementById('microsoftBtn').addEventListener('mouseleave', endLogoHover);
          document.getElementById('mathworksBtn').addEventListener('mouseenter', () => startLogoHover('mathworks'));
          document.getElementById('mathworksBtn').addEventListener('mouseleave', endLogoHover);
          document.getElementById('philipsBtn').addEventListener('mouseenter', () => startLogoHover('philips'));
          document.getElementById('philipsBtn').addEventListener('mouseleave', endLogoHover);
          return;
        }
      }
      
      requestAnimationFrame(scrambleDescription);
    }
    scrambleDescription();
  </script>
</body>
</html>

